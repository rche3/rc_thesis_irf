function [bs_beta_se, bs_beta_mean, irf_beta_bs] = lp_dwb_se(resid, y, x, beta, h, nlag, y_pos_control, ctrl_start, B)
% computes dependent wild bootstrap for NORMAL LP
% Inputs:
    % resid is original residual T x k computed from the estimated coefficients
    % y is lp response variable
    % x is lp regressor matrix
    % beta is estimated beta
    % h is desired lp horizon 
    % nlag is number of lagged obs for lp controls
    % ctrl_start is the position in x where controls begin
    % B is number of bootstrap replications
% Outputs:
    % bs_beta_se is matrix of beta standard errors
    % bs_beta_mean is the mean of bootstrap irfs
    % irf_beta_bs is size(x,1) x B empirical bootstrap distribution

% check the size is the same for resid, y, x
if size(resid, 1) == size(y, 1) && size(x, 1) == size(y,1)
    % pass
else
    disp('Error, dimensions of resid, regressors, and dep. var not equal')
end

% bootstrap settings
bs_samples = B;

% setup
T_resid = length(resid); % by design, this should be T - h + 1 in length, h \in [1,20]
demeaned_resid = resid - sum(resid)/T_resid;
beta_bs = nan(size(beta, 1), bs_samples);
T = T_resid - h - nlag; % our effective "T" which will be the length of the bootstrapped dependent variable
y_bs = zeros(T, 1);
[xrow, xcol] = size(x);

% DWB bootstrap settings
% e1 = (-sqrt(5)+1)/2; e2 = (sqrt(5)+1)/2;
% p1 = (sqrt(5)+1)/(2*sqrt(5)); p2 = 1-p1;
e1 = 1; e2 = -1;
p1 = 0.5; p2 = 1-p1;
values = [e1, e2];
probabilities = [p1, p2];
num_samples = T;
wild_settings = [values; probabilities];

% create residual bootstrap samples

for j = 1:bs_samples
% Print to the Command Window
    resid_sample = datasample(demeaned_resid, T, 'Replace', true);

    % create the bootstrap dependent variable y and x
    x_temp = x; % this is a temporary x variable which will become iteratively updated, initialised as our regressor matrix
    y_bs(1:nlag,:) = y(1:nlag,:);

    % create the DWB residuals
    dwb_innov = generate_dwb_resid(resid_sample, nlag, wild_settings);
    
    for i = nlag+1:T
        % compute and store y_bs variables
        y_bs(i) = x_temp(i,:) * beta + dwb_innov(i);
        
        % move the contemporaneously produced y to be the next period's first lag
        controls = x_temp(:,ctrl_start:end);
        controls(i+1, y_pos_control) = y_bs(i);
        
        x_temp = [x_temp(:,1:ctrl_start-1) controls];

        x(i,:) = ;



        %%% THE CORE IDEA HERE IS JUST TO INSERT Y_T accordingly without
        %%% having to relag all the other variables. Once they are used,
        %%% they are no longer needed.


        controls = x_temp(:,3:end);
%             from i = nlags +  h + 1 onwards, the entire x_temp control vector
%             as the regressor should be bootstrap variables
    end

    % estimate bootstrapped beta
    x_trunc = x_temp(1:T, :);
    results=nwest_rc(y_bs, x_trunc, 0); % note we don't need to lag x as input arg x is already lagged
    beta_bs(:, j) = results.beta;
end

% compute variance of the bootstrapped betas
irf_beta_bs = beta_bs;
cov_beta = cov(beta_bs');
bs_beta_var = diag(cov_beta);
bs_beta_se = bs_beta_var.^(1/2);

bs_beta_mean = mean(beta_bs, 2); % returns the mean of the betas across each row
% fprintf('bs beta mean for horizon %d is %.4f \n', h, bs_beta_mean(rpos));

end

